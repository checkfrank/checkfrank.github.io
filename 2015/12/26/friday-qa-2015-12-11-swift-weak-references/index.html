
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Friday Q&amp;A 2015-12-11：Swift 中的弱引用 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="[object Object]">
    
    <meta name="description" content="原文链接=https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html作者=Mike Ash原文日期=2015/12/11译者=riven校对=Cee定稿=千叶知风
&lt;!--此处开始正文--&gt;
即便你已经在火星的一个洞穴里，紧闭着你的双眼并且捂住你的耳朵，也避免不了 Swift 已经开源的事实。正因为开源，我们能够更加方便地去探索 Swift 中的很多有趣的特性，其中之一便是 Swift 中弱引用是如何工作的问题。">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/26/friday-qa-2015-12-11-swift-weak-references/" title="Friday Q&amp;A 2015-12-11：Swift 中的弱引用" itemprop="url">Friday Q&amp;A 2015-12-11：Swift 中的弱引用</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="[object Object]">[object Object]</a>
    </p>
  <p class="article-time">
    <time datetime="2015-12-26T08:40:56.336Z" itemprop="datePublished">2015-12-26</time>
    Updated:<time datetime="2015-12-26T08:40:47.174Z" itemprop="dateModified">2015-12-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#弱引用"><span class="toc-number">1.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#它是如何工作的呢？"><span class="toc-number">2.</span> <span class="toc-text">它是如何工作的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归零操作"><span class="toc-number">3.</span> <span class="toc-text">归零操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift_代码"><span class="toc-number">4.</span> <span class="toc-text">Swift 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整合"><span class="toc-number">5.</span> <span class="toc-text">整合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
		</div>
		
		<p>原文链接=<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html</a><br>作者=Mike Ash<br>原文日期=2015/12/11<br>译者=riven<br>校对=Cee<br>定稿=千叶知风</p>
<!--此处开始正文-->
<p>即便你已经在火星的一个洞穴里，紧闭着你的双眼并且捂住你的耳朵，<a href="https://swift.org/" target="_blank" rel="external">也避免不了 Swift 已经开源的事实</a>。正因为开源，我们能够更加方便地去探索 Swift 中的很多有趣的特性，其中之一便是 Swift 中弱引用是如何工作的问题。</p>
<a id="more"></a>
<h3 id="弱引用">弱引用</h3><p>在采用垃圾回收器或者引用计数进行内存管理的语言中，强引用可以使得特定的对象一直存活，但弱引用就无法保证。当一个对象被强引用时，它是不能够被销毁的；但是如果它是个弱引用，就可以。</p>
<p>当我们所提到「弱引用」时，通常的意思是指一个<em>归零</em>弱引用（Zeroing Weak Reference）。也就是说，当弱引用的目标对象被销毁时，弱引用就会变成 <code>nil</code>（校者注：<a href="https://www.mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.html" target="_blank" rel="external">看这篇文章了解更多</a>）。非归零弱引用也是存在的，它会导致一些陷阱（Trap）、崩溃（Crash）或者未定义行为的调用。比如你在 Objective-C 中使用 unsafe_unretained，或者在 Swift 中使用 unowned（Objective-C 未定义行为处理方式，而 Swift 却很可靠地处理这些崩溃）。</p>
<p>归零弱引用很方便使用，在基于引用计数进行内存管理的语言中他们是非常有用的。它们允许循环引用存在却不会产生死循环，并且不需要手动打破逆向引用。他们非常的有用，在苹果引入 ARC 和让弱引用在垃圾收集代码之外的语言层面上可用之前，<a href="https://www.mikeash.com/pyblog/introducing-mazeroingweakref.html" target="_blank" rel="external">我就已经实现了我自己的弱引用版本</a>。</p>
<h3 id="它是如何工作的呢？">它是如何工作的呢？</h3><p>归零弱引用比较典型的实现方式是保持一个对每个对象的所有弱引用列表。当对一个对象创建了弱引用，这个引用就会被添加到这个列表中。当这个引用被重新赋值或者超出了其作用域，它就会从列表中被移除。当一个对象被销毁，这个列表中的所有引用都会被归零。在多线程的情况下，其实现必须是同步获取一个弱引用并销毁一个对象，以避免竞态条件的出现：比如当一个线程释放某个对象的最后一个强引用而同时另一个线程却试图加载一个它的一个弱引用。</p>
<p>在我的实现中，每一个弱引用都是一个完整的对象。弱引用列表是一个弱引用对象的集合。虽然由于额外的转换和内存使用让效率变低了，但这种方式可以很方便的让这些引用变成完整的对象。</p>
<p>苹果公司的 Objective-C 的实现是这样的，每一个弱引用是一个指向目标对象的普通指针。编译器并不直接读写指针，而是使用一些帮助函数。当存储一个弱指针时，存储函数会将指针的位置注册为目标对象的一个弱引用。由于读取函数被集成进了引用计数系统，这就确保了在读取一个弱指针时，不会返回一个已经被释放了的对象的指针。</p>
<h3 id="归零操作">归零操作</h3><p>让我们创建一些代码来研究一下它们究竟是怎么运行的。</p>
<p>我们希望写一个函数能够 dump 一个对象的内存内容。这个函数接受一块内存区域，将其按指针大小进行分块，并且将最终的结果转换成一个易于查看的十六进制字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">contents</span><span class="params">(ptr: UnsafePointer&lt;Void&gt;, <span class="number">_</span> length: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wordPtr = <span class="type">UnsafePointer</span>&lt;<span class="type">UInt</span>&gt;(ptr)</span><br><span class="line">    <span class="keyword">let</span> words = length / <span class="built_in">sizeof</span>(<span class="type">UInt</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> wordChars = <span class="built_in">sizeof</span>(<span class="type">UInt</span>.<span class="keyword">self</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> buffer = <span class="type">UnsafeBufferPointer</span>&lt;<span class="type">UInt</span>&gt;(start: wordPtr, <span class="built_in">count</span>: words)</span><br><span class="line">    <span class="keyword">let</span> wordStrings = buffer.<span class="built_in">map</span>(&#123; word -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> wordString = <span class="type">String</span>(word, radix: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">while</span> wordString.characters.<span class="built_in">count</span> &lt; wordChars &#123;</span><br><span class="line">            wordString = <span class="string">"0"</span> + wordString</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordString</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> wordStrings.joinWithSeparator(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数会为一个对象创建一个 dump 函数。调用时传入一个对象，它会返回一个 dump 这个对象内容的函数。在函数内部，我们给对象保存了一个 <code>UnsafePointer</code>，而不是普通的引用。这样可以确保它不会和语言的引用计数系统发生交互。它允许我们可以在这个对象被销毁之后 dump 出它的内存，后面我们会介绍。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dumperFunc</span><span class="params">(obj: AnyObject)</span></span> -&gt; (<span class="type">Void</span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="type">String</span>(obj)</span><br><span class="line">    <span class="keyword">let</span> ptr = unsafeBitCast(obj, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> length = class_getInstanceSize(obj.<span class="keyword">dynamicType</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bytes = contents(ptr, length)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(objString)</span> <span class="subst">\(ptr)</span>: <span class="subst">\(bytes)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个包含弱引用变量的类，后面我会观察这个弱引用。我在弱引用变量的前后分别添加了一个 dummy 变量，以便于我们区分弱引用在 dump 出来的内存结构中的位置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakReferer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dummy1 = <span class="number">0x1234321012343210</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">WeakTarget</span>?</span><br><span class="line">    <span class="keyword">var</span> dummy2: <span class="type">UInt</span> = <span class="number">0xabcdefabcdefabcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们试一下! 我们先创建一个引用，然后 dump 它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007f8</span>a<span class="number">3861b920</span>: <span class="number">0000000107</span>ab<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>我们看到 <code>isa</code> 指针位于最开始的位置，紧随其后的是其它一些内部字段。<code>dummy1</code> 变量占据了第四块，<code>dummy2</code> 变量占据了第六块。正如我们所期望的那样，在他们之间的弱引用正好是零。</p>
<p>现在我们让这个弱引用指向一个目标对象，看看会变成什么样。我将这段代码放入一个 <code>do</code>语句中，以便于当目标对象超出作用域和被销毁时我们可以进行控制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">NSObject</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(target)</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSObject: 0x7fda<span class="number">6a21c6a0</span>&gt;</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fda6a000ad0: <span class="number">00000001050</span>a<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fda<span class="number">6a21c6a0</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>正如我们期望的那样，目标对象的指针直接存储在弱引用中。在目标对象被销毁之后，我们在 <code>do</code> 代码块之后再次调用 dump 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"></span><br><span class="line"><span class="type">WeakReferer</span> <span class="number">0x00007ffe32300060</span>: 000000010cfb44a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>它被归零了。点个赞!</p>
<p>仅仅为了好玩，我们用一个纯 Swift 对象作为对象来重复这个实验。不必要时，我并不是很想使用 Objective-C 中的东西。下面是一个纯 Swift 对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>让我们试一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br></pre></td></tr></table></figure>
<p>目标对象像我们期望的那样被归零了，然后被重新赋值：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fbe95121ce0 abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>然后当目标对象被销毁，引用应该被归零：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fbe95121ce0 abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>不幸的是它并没有被归零。可能是目标对象没有被销毁。一定是有某些东西让它继续活着！让我们再检查一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码，结果如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fd<span class="number">29a42a920</span> abcdefabcdefabcd</span><br><span class="line">WeakTarget deinit</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fd<span class="number">29a42a920</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>它消失了，但是弱引用并没有归零。怎么回事呢，我们发现了 Swift 的一个 bug！很神奇，这个 bug 一直没有被解决。你会想之前肯定已经有人已经注意到了这个问题。接下来，我们通过访问弱引用来产生一个崩溃，然后我们可以用这个 Swift 工程提交这个 bug ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">        <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(referer.target)</span><br></pre></td></tr></table></figure>
<p>下面就是崩溃信息：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>ff7aa2157f0 abcdefabcdefabcd</span><br><span class="line">WeakTarget deinit</span><br><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>ff7aa2157f0 abcdefabcdefabcd</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>哦，我的天呐！大爆炸在哪呢？应该有一个惊天动地的大爆炸呀！输出的内容表明一切工作正常，但我们可以清楚地从 dump 内容看到它并没有正常工作。</p>
<p>让我们再仔细检查一下。下面是一个经过修改的 <code>WeakTarget</code> 类，我们添加了一个 dummy 变量以便于区分 dump 的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dummy = <span class="number">0x0123456789abcdef</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Weak target deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一段新的代码，运行的程序和之前的基本相同，只不过每次 dump 都会输出两个对象（校者注：Target 和 Referer）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">let</span> targetDump: <span class="type">Void</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    targetDump = dumperFunc(target)</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line"></span><br><span class="line">    referer.target = target</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br><span class="line"><span class="built_in">print</span>(referer.target)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br></pre></td></tr></table></figure>
<p>让我们检查一下输出内容。referer 对象的生命周期和之前一样，它的 <code>target</code> 字段被顺利的归零了：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p><code>target</code> 首先作为一个普通对象，在各种头字段之后紧跟着我们的 <code>dummy</code> 字段：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>在给 <code>target</code> 字段赋值后，我们可以看到被填充的指针的值：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fe<span class="number">17341d270</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p><code>target</code> 对象还是和之前一样，但是它其中一个头字段增加了 2：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>目标对象像我们期望的那样被销毁了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weak <span class="keyword">target</span> deinit</span><br></pre></td></tr></table></figure>
<p>我们看到引用对象一直都有一个指针指向目标对象：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fe<span class="number">17341d270</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>并且目标对象本身一直存活着。和上次我们看到的相比，它的头字段减少了 2：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000002</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>访问 <code>target</code> 字段会产生 <code>nil</code> ，即便它没有被归零：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>再次 dump referer 对象的内容，从中我们看出仅仅访问 <code>target</code> 字段的行为已经改变了它。现在它被归零了：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>目标对象现在被完全抹掉了：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: 200007fe<span class="number">17342a04 30</span>0007fe<span class="number">17342811</span> ffffffffffff0002</span><br></pre></td></tr></table></figure>
<p>现在变的越来越有趣了。我们看到头字段会一会儿增加，一会儿减少；让我们看看是否能有重现出更多的信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line"><span class="keyword">let</span> targetDump = dumperFunc(target)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> a = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> b = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> <span class="built_in">c</span> = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> d = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> e = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> g = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> h = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> i = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> j = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> k = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00600000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00800000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00a00000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000008</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c0000000</span>c <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000010</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000014</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000018</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c0000001</span>c <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>我们看到每一个新的弱引用会让头字段中的第一个数增加 2。每一个新的强引用会让头字段中的第二个数增加 4。</p>
<p>回顾一下，下面这些就是目前我们所发现的：</p>
<ul>
<li>在内存中弱指针和普通指针是一样的.</li>
<li>当一个弱目标对象（WeakTarget）的 <code>deinit</code> 方法调用时，目标对象是<em>不会</em>被释放的，并且弱指针也<em>不会</em>被归零。</li>
<li>当目标对象的 <code>deinit</code> 方法执行之后，访问弱指针，它就会被归零并且弱目标对象也会被释放。</li>
<li>弱目标对象包含一个弱引用的引用计数，与强引用计数分离开。</li>
</ul>
<h3 id="Swift_代码">Swift 代码</h3><p>既然 Swift 已经开源，我们可以通过查看源代码来继续我们的观察。</p>
<p>在 Swift 标准库中用 <code>HeapObject</code> 类型来表示一个分配在堆上的对象，其实现可参考 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/SwiftShims/HeapObject.h#L33" target="_blank" rel="external">stdlib/public/SwiftShims/HeapObject.h</a>。看起来是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct HeapObject &#123;</span><br><span class="line">/// 这始终是一个有效的元数据对象的指针。</span><br><span class="line">struct HeapMetadata const *metadata;</span><br><span class="line"></span><br><span class="line">SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;</span><br><span class="line">// FIXME: 在 32 位的平台上分配了两个字大小的元数据。</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">HeapObject() = default;</span><br><span class="line"></span><br><span class="line">// 给新分配的堆内存初始化空间（对象alloc，是分配的堆内存）。</span><br><span class="line">constexpr HeapObject(HeapMetadata const *newMetadata) </span><br><span class="line">    : metadata(newMetadata)</span><br><span class="line">    , refCount(StrongRefCount::Initialized)</span><br><span class="line">    , weakRefCount(WeakRefCount::Initialized)</span><br><span class="line">&#123; &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Swift 的 <code>metadata</code> 字段就相当于 Objective-C 的 <code>isa</code> 字段，并且它们是兼容的。还有一些像 <code>NON_OBJC_MEMBERS</code> 这样的宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span><br><span class="line">  StrongRefCount refCount;                      \</span><br><span class="line">  WeakRefCount weakRefCount</span></span><br></pre></td></tr></table></figure>
<p>噢，快看！这就是我们的两个引用计数。</p>
<p>(附加问题：为什么这里强引用在前面，而在 dump 时确是弱引用在前面？)</p>
<p>引用计数是通过位于 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">stdlib/public/runtime/HeapObject.cpp</a> 文件中的一系列函数来进行管理的。比如，下面的 <code>swift_retain</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::swift_retain(HeapObject *object) &#123;</span><br><span class="line">SWIFT_RETAIN();</span><br><span class="line">    _swift_retain(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swift_retain_(HeapObject *object) &#123;</span><br><span class="line">    _swift_retain_inlined(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> swift::_swift_retain = _swift_retain_;</span><br></pre></td></tr></table></figure>
<p>这里面拐了几个弯，但它最终是调用头文件中的内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _swift_retain_inlined(HeapObject *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (object) &#123;</span><br><span class="line">    object-&gt;refCount.increment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，它会增加引用计数。下面是 increment 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  __atomic_fetch_add(&amp;refCount, RC_ONE, __ATOMIC_RELAXED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RC_ONE</code> 来自于一个枚举类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  RC_PINNED_FLAG = <span class="number">0x1</span>,</span><br><span class="line">  RC_DEALLOCATING_FLAG = <span class="number">0x2</span>,</span><br><span class="line"></span><br><span class="line">  RC_FLAGS_COUNT = <span class="number">2</span>,</span><br><span class="line">  RC_FLAGS_MASK = <span class="number">3</span>,</span><br><span class="line">  RC_COUNT_MASK = ~RC_FLAGS_MASK,</span><br><span class="line"></span><br><span class="line">  RC_ONE = RC_FLAGS_MASK + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相信你已经明白为什么每一个新的强引用会让头字段增加 4 了吧。这个枚举类型的前两位用来作为标志位。回想一下之前的 dump 结果，我们可以看到这些标志位。下面是一个弱目标对象在最后一个强引用消失之前和之后的结果：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">Weak target deinit</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000002</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>其中第二个字段开始是 4，表示引用计数为 1 并且没有标志位，之后变成了 2，表示引用计数为 0 和 <code>RC_DEALLOCATING_FLAG</code> 标志位被设定了。这个被析构的对象被放在了处于 <code>DEALLOCATING</code> 状态的位置。</p>
<p>（顺便说一句，<code>RC_PINNED_FLAG</code> 到底是用来干什么的呢？我查找了相关代码，除了能够表明一个「固定的对象（pinned object）」外，其它对于这个标记一无所知。如果你弄清楚了或者有一些相关的猜测，请给我留言。）</p>
<p>现在让我们看一看弱引用计数的实现。它有同样的枚举结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  <span class="comment">// There isn't really a flag here.</span></span><br><span class="line">  <span class="comment">// Making weak RC_ONE == strong RC_ONE saves an</span></span><br><span class="line">  <span class="comment">// instruction in allocation on arm64.</span></span><br><span class="line">  RC_UNUSED_FLAG = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RC_FLAGS_COUNT = <span class="number">1</span>,</span><br><span class="line">  RC_FLAGS_MASK = <span class="number">1</span>,</span><br><span class="line">  RC_COUNT_MASK = ~RC_FLAGS_MASK,</span><br><span class="line"></span><br><span class="line">  RC_ONE = RC_FLAGS_MASK + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是 2 的来源：其中有一个保留的标志位，目前尚未被使用。奇怪的是，关于这段代码的注释似乎是不正确的，这的 <code>RC_ONE</code> 等于 2，而强引用的 <code>RC_ONE</code> 等于 4。我猜它们曾经是相等的，但后来它被修改了而注释却没有更新。我只是想表明如果注释是无用的，那你为什么还要写它呢。</p>
<p>所有这些是如何和加载弱引用相关联的呢？它是由 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/runtime/HeapObject.cpp#L636" target="_blank" rel="external">swift_weakLoadStrong</a> 函数来处理的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HeapObject *swift::swift_weakLoadStrong(WeakReference *ref) &#123;</span><br><span class="line">  <span class="keyword">auto</span> object = ref-&gt;Value;</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (object-&gt;refCount.isDeallocating()) &#123;</span><br><span class="line">    swift_weakRelease(object);</span><br><span class="line">    ref-&gt;Value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> swift_tryRetain(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，惰性归零是如何工作的已经一目了然了。当加载一个弱引用时，如果目标对象正在被销毁，就会对这个引用进行归零。反之，会保留目标对象并返回它。进一步深挖一点，我们可以看到 <code>swift_weakRelease</code> 如何释放对象的内存，前提是它是最后一个引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::swift_weakRelease(HeapObject *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123;</span><br><span class="line">    <span class="comment">// 只有对象可以 weak-retained 和 weak-released</span></span><br><span class="line">    <span class="keyword">auto</span> metadata = object-&gt;metadata;</span><br><span class="line">    assert(metadata-&gt;isClassObject());</span><br><span class="line">    <span class="keyword">auto</span> classMetadata = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> ClassMetadata*&gt;(metadata);</span><br><span class="line">    assert(classMetadata-&gt;isTypeMetadata());</span><br><span class="line">    swift_slowDealloc(object, classMetadata-&gt;getInstanceSize(),</span><br><span class="line">                      classMetadata-&gt;getInstanceAlignMask());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：如果你正在查看版本库中的代码，使用「weak」命名的地方大多数都改成了「unowned」。上面的命名是截至撰写本文时最新的快照，但开发仍在继续。你可以查看和我这对应的版本库中的 2.2 版本的快照，或者获取最新的版本但是要注意命名的变化，并且实现也有可能发生了改变。)</p>
<h3 id="整合">整合</h3><p>我们已经在层级上自上往下地看到了 Swift 中的弱引用是如何实现的。那么在高层观察 Swift 的弱引用又是如何工作的呢？</p>
<ol>
<li>弱引用只是指向目标对象的指针。</li>
<li>在 Objective-C 中是<em>没有</em>办法单独追踪弱引用的。</li>
<li>相反，每一个 Swift 对象都有一个弱引用计数，和它的强引用计数相邻。</li>
<li>Swift 将对象的析构过程（deinit）和对象的释放（dealloc）解耦。一个对象可以被析构并释放它的外部资源，但不必释放对象本身所占用的内存。</li>
<li>当一个 Swift 对象的强引用计数变成零而弱引用计数仍大于零时，那么这个对象会被析构，但是不会被释放。</li>
<li>这意味着一个被释放对象的弱指针<em>仍然是一个有效的指针</em>，它可以被反向引用而不会崩溃或者加载垃圾数据。它们只是指向一个处于僵尸状态的对象。</li>
<li>当一个弱引用被加载时，运行时会检查目标对象的状态。如果目标对象是一个僵尸对象，然后它会对弱引用进行归零，也就是减少弱引用计数并返回 <code>nil</code>。</li>
<li>当僵尸对象的所有弱引用都被归零，那么这个僵尸对象就会被释放。</li>
</ol>
<p>比起 Objective-C 中的实现，这种设计会带来一些有趣的结果：</p>
<ul>
<li>不需要维护一个弱引用列表。这样既简化代码也提高了性能。</li>
<li>在一个线程归零一个弱引用和另外一个线程加载一个弱引用之间就不会存在竞态条件了。这也意味着加载一个弱引用和销毁一个弱引用对象不需要加锁。这也提高了性能。</li>
<li>一个对象即便没有了强引用，但是弱引用任然会导致该对象被分配的内存被占用，直到所有弱引用被加载或者被丢弃。这种做法临时增加了内存使用。但是要注意的是这个影响很小，当目标对象没有被释放时，它所占的内存大小只是实例本身。当最后一个强引用变成零时，所有的外部资源（包括用于存储的 <code>Array</code> 或 <code>Dictionary</code> 属性）都会被释放。弱引用会导致被分配的单个实例不会被释放，而不是整个对象树。</li>
<li>每一个对象都需要额外的内存来存储弱引用计数。但在实际的 64 位系统中，这似乎是无关紧要的。头字段要占据所有指针大小的块的数量，并且强和弱引用计数共享一个头字段。如果没有弱引用计数，强引用计数就会占据整个 64 位。通过使用<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="external">非指针（non-pointer）</a> <code>isa</code> 可以将强引用移到 <code>isa</code> 中，但我不确定那是不是很重要或者它未来会如何发展。 对于 32 位系统，弱引用计数会将对象的大小增加四个字节。然而，32 位系统如今已经没有那么重要了.</li>
<li>因为访问一个弱指针是如此的方便，所以 <code>unowned</code> 的语义也采用了相同的机制来实现。<code>unowned</code> 和 <code>weak</code> 工作方式是一样的，只是当目标对象被释放，<code>unowned</code> 会给你一个大大的失败，而不是给你返回一个 <code>nil</code> 。在 Objective-C 中，<code>__unsafe_unretained</code> 是作为一个带有未定义行为的原始指针来实现的，你可以快速的访问它，毕竟加载一个弱指针还是有点慢。</li>
</ul>
<h3 id="总结">总结</h3><p>Swift 的弱指针通过一种有趣的方式，既保证了速度和正确性，也保证较低的内存开销。通过追踪每个对象的弱引用计数，将对象的销毁和对象的析构过程分离开来，弱引用问题被安全而又快速的得到解决。正是由于可以查看标准库的源代码，这让我们可以在源代码级别看到究竟发生了什么，而不是像我们之前通过反编译和 dump 内存来进行研究。当然，正如你上面看到的那样，我们很难完全打破这个习惯。</p>
<p>今天就这样了。下次回来会带来更多的干货。由于假期的缘故，可能需要几周，但是我会在之前发布一篇稍微短一点的文章。不管怎样，给接下来的话题提更多的建议吧。周五问答是由读者们的想法驱动的，如果你有一个你希望了解的想法，<a href="mailto:mike@mikeash.com" target="_blank" rel="external">请告知我</a>!</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Mike-Ash/">Mike Ash</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Swift-进阶/">Swift 进阶</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/12/26/friday-qa-2015-12-11-swift-weak-references/" data-title="Friday Q&amp;A 2015-12-11：Swift 中的弱引用 | Hexo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/12/31/cocoapods-on-a-team/" title="在团队开发中使用 CocoaPods 的小技巧">
  <strong>PREVIOUS:</strong><br/>
  <span>
  在团队开发中使用 CocoaPods 的小技巧</span>
</a>
</div>


<div class="next">
<a href="/2015/12/17/per-view-auto-rotation-locking-made-easy-for-ios-8-and-9/"  title="在 iOS8 和 iOS9 中锁定视图自动旋转">
 <strong>NEXT:</strong><br/> 
 <span>在 iOS8 和 iOS9 中锁定视图自动旋转
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#弱引用"><span class="toc-number">1.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#它是如何工作的呢？"><span class="toc-number">2.</span> <span class="toc-text">它是如何工作的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归零操作"><span class="toc-number">3.</span> <span class="toc-text">归零操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift_代码"><span class="toc-number">4.</span> <span class="toc-text">Swift 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整合"><span class="toc-number">5.</span> <span class="toc-text">整合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/3D-Touch/" title="3D Touch">3D Touch<sup>1</sup></a></li>
		
			<li><a href="/categories/Swift-入门/" title="Swift 入门">Swift 入门<sup>16</sup></a></li>
		
			<li><a href="/categories/Swift-进阶/" title="Swift 进阶">Swift 进阶<sup>14</sup></a></li>
		
			<li><a href="/categories/WatchOS-2/" title="WatchOS 2">WatchOS 2<sup>3</sup></a></li>
		
			<li><a href="/categories/Xcode/" title="Xcode">Xcode<sup>1</sup></a></li>
		
			<li><a href="/categories/iOS-开发/" title="iOS 开发">iOS 开发<sup>2</sup></a></li>
		
			<li><a href="/categories/iOS开发/" title="iOS开发">iOS开发<sup>2</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/APPVENTURE/" title="APPVENTURE">APPVENTURE<sup>1</sup></a></li>
		
			<li><a href="/tags/AppCoda/" title="AppCoda">AppCoda<sup>3</sup></a></li>
		
			<li><a href="/tags/Apple/" title="Apple">Apple<sup>1</sup></a></li>
		
			<li><a href="/tags/Benedikt-Terhechte/" title="Benedikt Terhechte">Benedikt Terhechte<sup>1</sup></a></li>
		
			<li><a href="/tags/Crunchy-Development/" title="Crunchy Development">Crunchy Development<sup>2</sup></a></li>
		
			<li><a href="/tags/Erica-Sadun/" title="Erica Sadun">Erica Sadun<sup>7</sup></a></li>
		
			<li><a href="/tags/IOSCREATOR/" title="IOSCREATOR">IOSCREATOR<sup>1</sup></a></li>
		
			<li><a href="/tags/Jacob-Bandes-Storch/" title="Jacob Bandes-Storch">Jacob Bandes-Storch<sup>1</sup></a></li>
		
			<li><a href="/tags/Jameson-Quave/" title="Jameson Quave">Jameson Quave<sup>1</sup></a></li>
		
			<li><a href="/tags/Mike-Ash/" title="Mike Ash">Mike Ash<sup>1</sup></a></li>
		
			<li><a href="/tags/Natasha-The-Robot/" title="Natasha The Robot">Natasha The Robot<sup>6</sup></a></li>
		
			<li><a href="/tags/Ole-Begemann/" title="Ole Begemann">Ole Begemann<sup>1</sup></a></li>
		
			<li><a href="/tags/Raj-Kandathi/" title="Raj Kandathi">Raj Kandathi<sup>1</sup></a></li>
		
			<li><a href="/tags/Swift-and-Painless/" title="Swift and Painless">Swift and Painless<sup>2</sup></a></li>
		
			<li><a href="/tags/Terhechte/" title="Terhechte">Terhechte<sup>1</sup></a></li>
		
			<li><a href="/tags/Thomas/" title="Thomas">Thomas<sup>1</sup></a></li>
		
			<li><a href="/tags/Thomas-Hanning/" title="Thomas Hanning">Thomas Hanning<sup>3</sup></a></li>
		
			<li><a href="/tags/Thomas-Weston/" title="Thomas Weston">Thomas Weston<sup>1</sup></a></li>
		
			<li><a href="/tags/Tomasz-Szulc/" title="Tomasz Szulc">Tomasz Szulc<sup>3</sup></a></li>
		
			<li><a href="/tags/ericasadun/" title="ericasadun">ericasadun<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://yoursite.com" target="_blank" title="[object Object]">[object Object]</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
